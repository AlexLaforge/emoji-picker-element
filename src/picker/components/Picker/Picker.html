<svelte:options tag={null} />
<section
  class="picker { prefersDark ? 'prefers-dark ' : ''}"
  aria-label={i18n.regionLabel}
  {style}
  bind:this={rootElement}
>
  <!-- using a spacer div because this allows us to cover up the skintone picker animation -->
  <div class="pad-top"></div>
  <div class="search-row">
    <div class="search-wrapper"
         role="combobox"
         aria-expanded={!!(searchMode && currentEmojis.length)}
         aria-controls="search-results"
         aria-haspopup="listbox"
         aria-label={i18n.search}
    >
      <input
        id="search"
        class="search"
        type="search"
        enterkeyhint="search"
        placeholder={i18n.search}
        autocapitalize="none"
        autocomplete="off"
        spellcheck="true"
        aria-controls="search-results"
        aria-describedby="search-description"
        aria-autocomplete="list"
        aria-activedescendant={activeSearchItem === -1 ? '' : `emoji-${currentEmojis[activeSearchItem].unicode}`}
        bind:value={rawSearchText}
        on:keydown={onSearchKeydown}
      >
      <label class="sr-only" for="search">{i18n.search}</label>
      <span id="search-description" class="sr-only">{i18n.searchDescription}</span>
    </div>
    <div class="skintone-button-wrapper {skinTonePickerExpandedAfterAnimation ? 'expanded' : ''}">
      <button id="skintone-button"
              class="emoji {skinTonePickerExpanded ? 'hide-focus' : ''}"
              aria-label={skinToneButtonLabel}
              title={skinToneButtonLabel}
              aria-describedby="skintone-description"
              aria-haspopup="listbox"
              aria-expanded={skinTonePickerExpanded}
              aria-controls="skintone-list"
              on:click={onClickSkinToneButton}
      >{skinToneText}</button>
    </div>
    <span id="skintone-description" class="sr-only">{i18n.skinToneDescription}</span>
    <div id="skintone-list"
         class="skintone-list {skinTonePickerExpanded ? '' : 'hidden no-animate'}"
         style="{skinTonePickerExpanded ? 'transform: translateY(0);' : 'transform: translateY(calc(-1 * var(--num-skintones) * var(--total-emoji-size)))'}"
         role="listbox"
         aria-label={i18n.skinTonesTitle}
         aria-activedescendant="skintone-{activeSkinTone}"
         aria-hidden={!skinTonePickerExpanded}
         on:keydown={onSkinToneOptionKeydown}
         on:focusout={onSkinToneOptionsBlur}
         on:click={onClickSkinToneOption}
         bind:this={skinToneDropdown}
    >
      {#each skinTones as skinTone, i (skinTone)}
        <button id="skintone-{i}"
                class="emoji skintone-option hide-focus {i === activeSkinTone ? 'active' : ''}"
                aria-selected={i === activeSkinTone}
                role="option"
                title={i18n.skinTones[i]}
                tabindex="-1"
      >
          <!-- I would use an aria-label here, but Safari+VoiceOver does not read it
               out unless I do it this way -->
          <span class="no-pointer" aria-hidden="true">{skinTone}</span>
          <span class="sr-only">{i18n.skinTones[i]}</span>
        </button>
      {/each}
    </div>

  </div>
  <div class="nav"
       role="tablist"
       style="grid-template-columns: repeat({groups.length}, 1fr);"
       aria-label={i18n.categoriesLabel}
       on:keydown={onNavKeydown}>
    {#each groups as group (group.id)}
      <button role="tab"
              class="nav-button"
              aria-controls="tab-{group.id}"
              aria-label={i18n.categories[group.name]}
              aria-selected={group.id === group.id}
              title={i18n.categories[group.name]}
              on:click={() => onNavClick(group)}>
        <div class="emoji">
          {group.emoji}
        </div>
      </button>
    {/each}
  </div>
  <div class="indicator-wrapper"
       aria-hidden="true">
    <div class="indicator"
         style={indicatorStyle}
         use:calculateIndicatorWidth>
    </div>
  </div>

  <div class="message {message ? '' : 'gone'}"
       role="alert"
       aria-live="polite">
    {message}
  </div>

  <div class="tabpanel {message ? 'gone': ''}"
       role={searchMode ? 'region' : 'tabpanel'}
       aria-label={searchMode ? i18n.searchResultsLabel : i18n.categories[currentGroup.name]}
       id={searchMode ? '' : `tab-${currentGroup.id}`}
       tabindex="0"
       on:click={onEmojiClick}
  >
    {#each currentEmojisWithCategories as emojiWithCategory (emojiWithCategory.category)}
      <div class="category {currentEmojisWithCategories.length > 1 ? '' : 'gone'}" aria-hidden="true">
        {emojiWithCategory.category || i18n.categories[currentGroup.name]}
      </div>
      <div class="emoji-menu"
           role={searchMode ? 'listbox' : 'menu'}
           aria-label={searchMode ? i18n.searchResultsLabel : (emojiWithCategory.category || i18n.categories[currentGroup.name])}
           id={searchMode ? 'search-results' : ''}
           use:calculateEmojiGridWith
      >
        {#each emojiWithCategory.emojis as emoji, i (emoji.id)}
          <button role={searchMode ? 'option' : 'menuitem'}
                  aria-selected={searchMode ? i == activeSearchItem : ''}
                  aria-label={emoji.label}
                  title={emoji.title}
                  class="emoji {searchMode && i === activeSearchItem ? 'active' : ''}"
                  data-emoji={emoji.id}>
            {#if emoji.unicode}
              {unicodeWithSkin(emoji, currentSkinTone)}
            {:else}
              <img class="custom-emoji"
                   src={emoji.url}
                   loading="lazy"
                   alt=""
              />
            {/if}
          </button>
        {/each}
      </div>
    {/each}
  </div>
  <div class="favorites emoji-menu {message ? 'gone': ''}"
       role="menu"
       aria-label={i18n.favoritesLabel}
       style="padding-right: {scrollbarWidth}px;"
       on:click={onEmojiClick}
       data-testid="favorites">
    <!-- TODO: the reason so much of this emoji logic is duplicated is because it would be wasteful
         or incorrect to extract this logic into a custom Svelte component, because in customElements
         mode, Svelte will render _all_ components as custom elements. Ideally we just want one
         custom element wrapper around the outer component -->
    {#each currentFavorites as emoji, i (emoji.id)}
      <button role="menuitem"
              aria-label={emoji.label}
              title={emoji.title}
              class="emoji"
              data-emoji={emoji.id}>
        {#if emoji.unicode}
          {unicodeWithSkin(emoji, currentSkinTone)}
        {:else}
          <img class="custom-emoji"
               src={emoji.url}
               loading="lazy"
               alt=""
          />
        {/if}
      </button>
    {/each}
  </div>
  <div aria-hidden="true" class="hidden abs-pos">
    <button tabindex="-1" class="emoji baseline-emoji" bind:this={baselineEmoji}>ðŸ˜€</button>
  </div>
</section>